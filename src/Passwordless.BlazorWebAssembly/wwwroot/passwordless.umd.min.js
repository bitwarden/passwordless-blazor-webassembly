!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).Passwordless={})}(this,(function(e){"use strict";async function r(){return!!t()&&PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}function t(){return void 0!==window.PublicKeyCredential&&"function"==typeof window.PublicKeyCredential}async function i(){const e=window.PublicKeyCredential;return!!e.isConditionalMediationAvailable&&e.isConditionalMediationAvailable()}function n(e){if("string"!=typeof e){const r="Cannot convert from Base64Url to ArrayBuffer: Input was not of type string";throw console.error(r,e),new TypeError(r)}const r=e.replace(/-/g,"+").replace(/_/g,"/");const t=(4-r.length%4)%4,i=r.padEnd(r.length+t,"="),n=window.atob(i),o=new Uint8Array(n.length);for(let e=0;e<n.length;e++)o[e]=n.charCodeAt(e);return o}function o(e){const r=(()=>{if(Array.isArray(e))return Uint8Array.from(e);if(e instanceof ArrayBuffer)return new Uint8Array(e);if(e instanceof Uint8Array)return e;const r="Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array";throw console.error(r,e),new Error(r)})();let t="";for(let e=0;e<r.byteLength;e++)t+=String.fromCharCode(r[e]);const i=window.btoa(t);return i.replace(/\+/g,"-").replace(/\//g,"_").replace(/=*$/g,"")}function s(e){return function(e){if("object"==typeof(r=e)&&null!==r&&"message"in r&&"string"==typeof r.message)return e;var r;try{return new Error(JSON.stringify(e))}catch(r){return new Error(String(e))}}(e).message}e.Client=class{constructor(e){this.config={apiUrl:"https://v4.passwordless.dev",apiKey:"",origin:window.location.origin,rpid:window.location.hostname},this._clientVersion="js-1.1.0",this.abortController=new AbortController,Object.assign(this.config,e)}async register(e,r){var t;try{this.assertBrowserSupported();const i=await this.registerBegin(e);if(i.error)return console.error(i.error),{error:i.error};i.data.challenge=n(i.data.challenge),i.data.user.id=n(i.data.user.id),null===(t=i.data.excludeCredentials)||void 0===t||t.forEach((e=>{e.id=n(e.id)}));const o=await navigator.credentials.create({publicKey:i.data});if(!o){const e={from:"client",errorCode:"failed_create_credential",title:"Failed to create credential (navigator.credentials.create returned null)"};return console.error(e),{error:e}}return await this.registerComplete(o,i.session,r)}catch(e){const r={from:"client",errorCode:"unknown",title:s(e)};return console.error(e),console.error(r),{error:r}}}async signinWithId(e){return this.signin({userId:e})}async signinWithAlias(e){return this.signin({alias:e})}async signinWithAutofill(){if(!await i())throw new Error("Autofill authentication (conditional meditation) is not supported in this browser");return this.signin({autofill:!0})}async signinWithDiscoverable(){return this.signin({discoverable:!0})}abort(){this.abortController&&this.abortController.abort()}isPlatformSupported(){return r()}isBrowserSupported(){return t()}isAutofillSupported(){return i()}async registerBegin(e){const r=await fetch(`${this.config.apiUrl}/register/begin`,{method:"POST",headers:this.createHeaders(),body:JSON.stringify({token:e,RPID:this.config.rpid,Origin:this.config.origin})}),t=await r.json();return r.ok?t:{error:{...t,from:"server"}}}async registerComplete(e,r,t){const i=e.response,n=await fetch(`${this.config.apiUrl}/register/complete`,{method:"POST",headers:this.createHeaders(),body:JSON.stringify({session:r,response:{id:e.id,rawId:o(e.rawId),type:e.type,clientExtensionResults:e.getClientExtensionResults(),response:{AttestationObject:o(i.attestationObject),clientDataJson:o(i.clientDataJSON)}},nickname:t,RPID:this.config.rpid,Origin:this.config.origin})}),s=await n.json();return n.ok?s:{error:{...s,from:"server"}}}async signin(e){try{this.assertBrowserSupported(),this.handleAbort(),e||(e={discoverable:!0});const r=await this.signinBegin(e);if(r.error)return r;const t=await navigator.credentials.get({publicKey:r.data,mediation:"autofill"in e?"conditional":void 0,signal:this.abortController.signal});return await this.signinComplete(t,r.session)}catch(e){const r={from:"client",errorCode:"unknown",title:s(e)};return console.error(e),console.error(r),{error:r}}}async stepup(e){try{if(this.assertBrowserSupported(),this.handleAbort(),!e.signinMethod)throw new Error("You need to provide the signinMethod");e.purpose||(e.purpose="step-up");const r=await this.signinBegin(e.signinMethod,e.purpose);if(r.error)return r;const t=await navigator.credentials.get({publicKey:r.data,mediation:"autofill"in e.signinMethod?"conditional":void 0,signal:this.abortController.signal});return await this.signinComplete(t,r.session)}catch(e){const r={from:"client",errorCode:"unknown",title:s(e)};return console.error(e),console.error(r),{error:r}}}async signinBegin(e,r){var t;const i=await fetch(`${this.config.apiUrl}/signin/begin`,{method:"POST",headers:this.createHeaders(),body:JSON.stringify({userId:"userId"in e?e.userId:void 0,alias:"alias"in e?e.alias:void 0,RPID:this.config.rpid,Origin:this.config.origin,purpose:r})}),o=await i.json();return i.ok?{...o,data:{...o.data,challenge:n(o.data.challenge),allowCredentials:null===(t=o.data.allowCredentials)||void 0===t?void 0:t.map((e=>({...e,id:n(e.id)})))}}:{error:{...o,from:"server"}}}async signinComplete(e,r){const t=e.response,i=await fetch(`${this.config.apiUrl}/signin/complete`,{method:"POST",headers:this.createHeaders(),body:JSON.stringify({session:r,response:{id:e.id,rawId:o(new Uint8Array(e.rawId)),type:e.type,clientExtensionResults:e.getClientExtensionResults(),response:{authenticatorData:o(t.authenticatorData),clientDataJson:o(t.clientDataJSON),signature:o(t.signature)}},RPID:this.config.rpid,Origin:this.config.origin})}),n=await i.json();return i.ok?n:{error:{...n,from:"server"}}}handleAbort(){this.abort(),this.abortController=new AbortController}assertBrowserSupported(){if(!t())throw new Error("WebAuthn and PublicKeyCredentials are not supported on this browser/device")}createHeaders(){return{ApiKey:this.config.apiKey,"Content-Type":"application/json","Client-Version":this._clientVersion}}get clientVersionRegex(){return/^[a-z]+-\d+\.\d+\.\d+$/}set clientVersion(e){if(!this.clientVersionRegex.test(this.clientVersion))throw new Error("`Client-Version` has already been set.");if(!this.clientVersionRegex.test(e))throw new Error("Invalid `Client-Version` format. Expected format is 'prefix-x.x.x' where prefix is a lowercase string.");this._clientVersion=`${e}+${this.clientVersion}`}get clientVersion(){return this._clientVersion}},e.isAutofillSupported=i,e.isBrowserSupported=t,e.isPlatformSupported=r}));
